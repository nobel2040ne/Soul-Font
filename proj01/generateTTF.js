const fs = require('fs');
const path = require('path');
const PNG = require('pngjs').PNG;
const ImageTracer = require('./public/javascript/imagetracer_v1.2.1.js');
const svg2ttf = require('svg2ttf');
const opentype = require('opentype.js');
const SVGIcons2SVGFontStream = require('svgicons2svgfont').default || require('svgicons2svgfont');

const userId = process.argv[2];
if (!userId) {
    console.error('Usage: node generateTTF.js <userId>');
    process.exit(1);
}

// [수정됨] 사용자별 고유 디렉토리를 기본 경로로 설정
const baseDir = path.join(__dirname, 'FONT', userId.toString());
const flippedDir = path.join(baseDir, 'flipped_result');
const svgDir = path.join(baseDir, 'svg');
const svgFontsDir = path.join(baseDir, 'svg_fonts');
const ttfDir = path.join(baseDir, 'ttf_fonts');

// 필요한 디렉토리 생성
// recursive: true 옵션 덕분에 FONT/<userId>/flipped_result 같은 중첩 경로도 한 번에 생성됩니다.
[baseDir, flippedDir, svgDir, svgFontsDir, ttfDir].forEach(dir => {
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
});

// PNG 파일 목록 가져오기
// 이제 FONT/<userId>/flipped_result/ 에서 파일을 읽어옵니다.
const files = fs.readdirSync(flippedDir).filter(f => f.endsWith('.png'));

const option = {
    ltres: 1,
    qtres: 1,
    strokewidth: 0.5,
    pathomit: 8,
    blurradius: 0,
    blurdelta: 10,
    pal: [{ r: 0, g: 0, b: 0, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }],
    linefilter: true
};

async function generateFont(userId) {
    const fontName = `user_font_${userId}`;
    const postScriptName = `user_font-${userId}-Regular`; // PostScript 이름 표준화 (공백 제거, 대시 사용)

    // PNG → SVG 변환
    for (const file of files) {
        const fileName = path.basename(file, '.png');
        const pngPath = path.join(flippedDir, file);
        const svgPath = path.join(svgDir, `${fileName}.svg`);

        const data = fs.readFileSync(pngPath);
        const png = PNG.sync.read(data);

        const myImageData = { width: png.width, height: png.height, data: png.data };
        const svgString = ImageTracer.imagedataToSVG(myImageData, option);

        fs.writeFileSync(svgPath, svgString);
        console.log(`Converted ${file} to SVG`);
    }

    // SVG 폰트 스트림 생성
    const fontStream = new SVGIcons2SVGFontStream({
        fontName: fontName,
        normalize: true,
        fontHeight: 1000,
        centerHorizontally: true,
        centerVertically: true,
        descent: 200,
    });
    
    // [경로 수정됨] 모든 경로는 사용자별 디렉토리 하위에 생성됩니다.
    const svgFontPath = path.join(svgFontsDir, 'font_temp.svg');
    const ttfOutputPath = path.join(ttfDir, `${fontName}.ttf`);
    const finalTTFPath = path.join(ttfDir, `${fontName}_final.ttf`);  // 후처리 완료본

    const writeStream = fs.createWriteStream(svgFontPath);
    fontStream.pipe(writeStream);

    for (const file of files) {
        const fileName = path.basename(file, '.png');
        const svgPath = path.join(svgDir, `${fileName}.svg`);

        let codePoint = 0x20; // 기본값은 스페이스
        const match = fileName.match(/inferred_(.+)/);
        if (match) {
            const hexStr = match[1];
            codePoint = parseInt(hexStr, 16);
            if (isNaN(codePoint)) codePoint = 0x20;
        }

        const glyphStream = fs.createReadStream(svgPath);
        glyphStream.metadata = {
            unicode: [String.fromCodePoint(codePoint)],
            name: `uni${codePoint.toString(16).toUpperCase()}`
        };

        fontStream.write(glyphStream);
        console.log(`Added glyph for code point U+${codePoint.toString(16).toUpperCase()}`);
    }

    fontStream.end();

    writeStream.on('finish', async () => {
        try {
            const svgFontData = fs.readFileSync(svgFontPath, 'utf8');
            const ttf = svg2ttf(svgFontData, {});
            fs.writeFileSync(ttfOutputPath, Buffer.from(ttf.buffer));
            console.log(`TTF font generated at: ${ttfOutputPath}`);

            // === 후처리 시작 ===
            const font = await opentype.load(ttfOutputPath);
            
            // 폰트 메타데이터 강화 (Office 호환성 향상)
            font.names.fontFamily = { en: fontName };
            font.names.fullName = { en: `${fontName} Regular` };
            font.names.postScriptName = { en: postScriptName };
            font.names.uniqueSubfamily = { en: `${fontName} Regular` };
            font.names.preferredFamily = { en: fontName };
            font.names.preferredSubfamily = { en: 'Regular' };
            font.names.version = { en: 'Version 1.000' };
            font.names.manufacturer = { en: 'Generated by Soul Font' };
            font.names.designer = { en: 'nobel and lukple' };
            font.names.description = { en: `A custom font generated for user ${userId}.` };
            font.names.license = { en: 'This font is for personal and non-commercial use.' };
            font.names.licenseURL = { en: 'nobel2040ne@sasa.hs.kr' };
            font.names.copyright = { en: `Copyright (c) 2025, ${fontName}` };
            font.names.trademark = { en: `${fontName} is a trademark of Your Name or Company.` };

            // 메트릭스 설정
            font.ascender = 900;
            font.descender = -200;
            font.unitsPerEm = 1000;

            // OS/2 테이블 설정 강화
            font.tables.os2.usWeightClass = 400;
            font.tables.os2.usWidthClass = 5;
            font.tables.os2.fsSelection = 0x04;
            font.tables.os2.ulCodePageRange1 = 1;
            font.tables.os2.ulCodePageRange2 = 0;
            font.tables.os2.ulCodePageRange3 = 0;
            font.tables.os2.ulCodePageRange4 = 0;
            font.tables.os2.ulCharRange = [
                0x00000001, // Basic Latin
                0x00000000,
                0x00000000,
                0x00000000,
            ];
            font.tables.os2.achVendID = 'XXXX';

            const buffer = font.toArrayBuffer();
            fs.writeFileSync(finalTTFPath, Buffer.from(buffer));
            console.log(`✅ Final TTF with metadata saved at: ${finalTTFPath}`);

            // 임시 SVG 폰트 파일 삭제
            fs.unlinkSync(svgFontPath);
            console.log(`Cleaned up temporary SVG font file: ${svgFontPath}`);

        } catch (err) {
            console.error('❌ Error during TTF post-processing:', err);
        }
    });

    writeStream.on('error', (err) => {
        console.error('Error writing SVG font:', err);
    });
}

generateFont(userId).catch(console.error);